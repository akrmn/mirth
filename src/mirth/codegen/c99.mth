module(mirth/codegen/c99)
import(mirth/codegen/common)

###############
# C99 Codegen #
###############

def(run-output-c99!, Token Path -- +IO,
    load-output-path!
    STR_BUF create-file! codegen-start!
    c99-emit-header!
    # c99-emit-strings!
    # c99-emit-buffers!
    # c99-emit-nominals!
    # c99-emit-externals!
    # c99-emit-word-sigs!
    # c99-emit-word-defs!
    # c99-emit-main!
    # drop # TODO emit
    c99-emit-main! # elab-arrow! drop
    codegen-end!)

quad def-static-buffer(C99_DEPTH)
def(c99-depth@, -- Int +Codegen, C99_DEPTH @)
def(c99-depth!, Int -- +Codegen, C99_DEPTH !)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;
    )

# def(c99-emit-strings!, +IO,
#     "#define STRINGS_SIZE " . strings-size@ .n "" ;
#     "static const char strings[STRINGS_SIZE] = { " ;
#     0
#     while(dup strings-size@ <,
#         dup STRINGS_BUF u8@@ U8->Int dup .n "," .
#         if(id, .lf)
#         1+
#     ) drop
#     "};" ;;)

# def(c99-emit-buffers!, +IO,
#     0
#     while(dup num-names@ <,
#         dup Int->Name c99-emit-buffer!
#         1+)
#     .lf drop)

# def(c99-emit-buffer!, Name -- +IO,
#     name-is-buffer? if(
#         " volatile u8 b" . dup .name "[" . dup name-buffer@ buffer-size@ .n "] = {0};" ;
#         " void mw" . dup .name " (void) { push((i64)b" . .name "); }" ;  ,
#         drop
#     ))

# def(c99-emit-prims!, +IO,
#     " i64 pop (void) {" ;
#     "    if (sc < STACK_SIZE) {" ;
#     "        return stack[sc++];" ;
#     "    } else {" ;
#     "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
#     "        exit(1);" ;
#     "        return 0;" ;
#     "    }" ;
#     "}" ;;
#     " void* pop_ptr (void) {" ;
#     "    i64 x = (i64)pop();" ;
#     "    return (void*)x;" ;
#     "}";;
#     " u8 pop_u8 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (u8)x;" ;
#     "}";;
#     " u16 pop_u16 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (u16)x;" ;
#     "}";;
#     " u32 pop_u32 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (u32)x;" ;
#     "}";;
#     " u64 pop_u64 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (u64)x;" ;
#     "}";;
#     " i8 pop_i8 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (i8)x;" ;
#     "}";;
#     " i16 pop_i16 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (i16)x;" ;
#     "}";;
#     " i32 pop_i32 (void) {" ;
#     "    i64 x = pop();" ;
#     "    return (i32)x;" ;
#     "}";;
#     " i64 pop_i64 (void) {" ;
#     "    return pop();" ;
#     "}";;

#     " void push (i64 x) {" ;
#     "    if (sc > 0) {" ;
#     "        stack[--sc] = x;" ;
#     "    } else {" ;
#     "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
#     "        exit(1);" ;
#     "    }" ;
#     "}" ;;

#     PRIM_ID .p " {" ;
#     "}" ;;

#     PRIM_DUP .p " {" ;
#     "    i64 x = pop();" ;
#     "    push(x); push(x);" ;
#     "}" ;;

#     PRIM_DROP .p " {" ;
#     "    pop();" ;
#     "}" ;;

#     PRIM_SWAP .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(x); push(y);" ;
#     "}" ;;

#     PRIM_INT_ADD .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(x + y);" ;
#     "}" ;;

#     PRIM_INT_SUB .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y - x);" ;
#     "}" ;;

#     PRIM_INT_MUL .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(x * y);" ;
#     "}" ;;

#     PRIM_INT_DIV .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y / x);" ;
#     "}" ;;

#     PRIM_INT_MOD .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y % x);" ;
#     "}" ;;

#     PRIM_INT_EQ .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(x == y);" ;
#     "}" ;;

#     PRIM_INT_LT .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y < x);" ;
#     "}" ;;

#     PRIM_INT_LE .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y <= x);" ;
#     "}" ;;

#     PRIM_INT_AND .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y & x);" ;
#     "}" ;;

#     PRIM_INT_OR .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y | x);" ;
#     "}" ;;

#     PRIM_INT_XOR .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y ^ x);" ;
#     "}" ;;

#     PRIM_INT_SHL .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y << x);" ;
#     "}" ;;

#     PRIM_INT_SHR .p " {" ;
#     "    i64 x = pop();" ;
#     "    i64 y = pop();" ;
#     "    push(y >> x);" ;
#     "}" ;;

#     PRIM_POSIX_WRITE .p " {" ;
#     "    usize n = (usize)pop();" ;
#     "    void* p = pop_ptr();" ;
#     "    int f = (int)pop();" ;
#     "    write(f, p, n);" ; # TODO: push return code
#     "}" ;;

#     PRIM_POSIX_READ .p " {" ;
#     "    usize n = (usize)pop();" ;
#     "    void* p = pop_ptr();" ;
#     "    int f = (int)pop();" ;
#     "    push(read(f,p,n));" ;
#     "}" ;;

#     PRIM_POSIX_OPEN .p " {" ;
#     "    int m = (int)pop();" ;
#     "    int f = (int)pop();" ;
#     "    void* p = pop_ptr();" ;
#     "    push(open(p,f,m));" ;
#     "}" ;;

#     PRIM_POSIX_CLOSE .p " {" ;
#     "    int x = (int)pop();" ;
#     "    push(close(x));" ;
#     "}" ;;

#     PRIM_POSIX_EXIT .p " {" ;
#     "    int x = (int)pop();" ;
#     "    exit(x);" ;
#     "}" ;;

#     PRIM_POSIX_MMAP .p " {" ;
#     "    #ifdef MIRTH_WIN32" ;
#     "    pop(); pop(); pop(); pop();" ;
#     "    usize b = (usize)pop();" ;
#     "    pop();" ;
#     "    push((i64)malloc(b));" ;
#     "    #else" ;
#     "    int f = (int)pop();" ;
#     "    int e = (int)pop();" ;
#     "    int d = (int)pop();" ;
#     "    int c = (int)pop();" ;
#     "    usize b = (usize)pop();" ;
#     "    void* a = pop_ptr();" ;
#     "    void* p = mmap(a,b,c,d,e,f);" ;
#     "    push((i64)p);" ;
#     "    #endif" ;
#     "}" ;;

#     PRIM_DEBUG .p " {" ;
#     "    write(2, \"??\", 2);" ;
#     "    char c[32] = {0};" ;
#     "    char* cp;" ;
#     "    usize n;" ;
#     "    i64 x; i64 y;" ;
#     "    for (long i = STACK_SIZE-1; i >= (long)sc; i--) {" ;
#     "        cp = c+30;" ;
#     "        x = (i64)stack[i];" ;
#     "        n = 1;" ;
#     "        y = x; if (x < 0) { x = -x; }" ;
#     "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
#     "        if (y < 0) { *cp-- = '-'; n++; } " ;
#     "        *cp = ' ';" ;
#     "        write(2, cp, n);" ;
#     "    }" ;
#     "    write(2, \"\\n\", 1);" ;
#     "}" ;;

#     PRIM_MIRTH_REVISION .p " {" ;
#     "    push(" . NEW_MIRTH_REVISION .n ");";
#     "}" ;;

#     PRIM_MEM_GET .p " {" ;
#     "    stack[sc] = *(i64*)(stack[sc]);" ;
#     "}" ;;

#     PRIM_MEM_SET .p " {" ;
#     "    i64* x = pop_ptr();" ;
#     "    *x = (i64)pop();" ;
#     "}" ;;

#     PRIM_MEM_GET_BYTE .p " {" ;
#     "    u8* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_BYTE .p " {" ;
#     "    u8* x = pop_ptr();" ;
#     "    *x = pop_u8();" ;
#     "}" ;;

#     PRIM_MEM_GET_U8 .p " {" ;
#     "    u8* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_U8 .p " {" ;
#     "    u8* x = pop_ptr();" ;
#     "    *x = pop_u8();" ;
#     "}" ;;

#     PRIM_MEM_GET_U16 .p " {" ;
#     "    u16* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_U16 .p " {" ;
#     "    u16* x = pop_ptr();" ;
#     "    *x = pop_u16();" ;
#     "}" ;;

#     PRIM_MEM_GET_U32 .p " {" ;
#     "    u32* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_U32 .p " {" ;
#     "    u32* x = pop_ptr();" ;
#     "    *x = pop_u32();" ;
#     "}" ;;

#     PRIM_MEM_GET_U64 .p " {" ;
#     "    u64* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_U64 .p " {" ;
#     "    u64* x = pop_ptr();" ;
#     "    *x = pop_u64();" ;
#     "}" ;;

#     PRIM_MEM_GET_I8 .p " {" ;
#     "    i8* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_I8 .p " {" ;
#     "    i8* x = pop_ptr();" ;
#     "    *x = pop_i8();" ;
#     "}" ;;

#     PRIM_MEM_GET_I16 .p " {" ;
#     "    i16* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_I16 .p " {" ;
#     "    i16* x = pop_ptr();" ;
#     "    *x = pop_i16();" ;
#     "}" ;;

#     PRIM_MEM_GET_I32 .p " {" ;
#     "    i32* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_I32 .p " {" ;
#     "    i32* x = pop_ptr();" ;
#     "    *x = pop_i32();" ;
#     "}" ;;

#     PRIM_MEM_GET_I64 .p " {" ;
#     "    i64* x = pop_ptr();" ;
#     "    push(*x);" ;
#     "}" ;;

#     PRIM_MEM_SET_I64 .p " {" ;
#     "    i64* x = pop_ptr();" ;
#     "    *x = pop_i64();" ;
#     "}" ;;

#     PRIM_RUNNING_OS .p " {" ;
#     "#if defined(MIRTH_WIN32)" ;
#     "    push(" . WIN32 .n ");" ;
#     "#elif defined(MIRTH_LINUX)" ;
#     "    push(" . LINUX .n ");" ;
#     "#elif defined(MIRTH_MACOS)" ;
#     "    push(" . MACOS .n ");" ;
#     "#else" ;
#     "    push(" . UNKNOWN .n ");" ;
#     "#endif" ;
#     "}" ;;

#     PRIM_CAST .p " { }" ;;

#     PRIM_PTR+ .p " {" ;
#     "   u8* x = pop_ptr();" ;
#     "   i64 y = pop();" ;
#     "   push((i64)(x + y));" ;
#     "}" ;;

#     )

# def(c99-emit-externals!, +IO,
#     0
#     while(dup num-names@ <,
#         dup Int->Name c99-emit-external!
#         1+)
#     .lf drop)

# def(c99-emit-external!, Name -- +IO,
#     name-is-external? if(
#         name-sig? sig-arity
#         dup 2 >= if(
#             "can't declare external with multiple return values" panic!,

#             dup 1 >= if(
#                 "i64 " .,
#                 "void " .
#             )
#         )
#         dip(dip(dup .name))
#         " (" .
#         over dup if(
#             "i64" .
#             1- while(dup,
#                 ", i64" .
#                 1-
#             ) drop,
#             drop
#         ) ");" ;

#         " void mw" . dip(dip(dup .name)) " (void) {" ;
#         over while(dup,
#             "    i64 x" . dup .n " = pop();" ;
#             1-
#         ) drop
#         dup if("    push(", "    ") .
#         dip(dip(dup .name))
#         "(" .
#         dip(dup if(
#             "x1" .
#             dup 1-
#             while(dup,
#                 ", x" .
#                 dup2 - 1+ .n
#                 1-
#             ) drop,
#             id
#         ))
#         ")" .
#         dup if(");", ";") ;
#         "}" ;

#         drop3,

#         drop
#     ))

# def(c99-emit-word-sigs!, +IO,
#     0
#     while(dup num-names@ <,
#         dup Int->Name c99-emit-word-sig!
#         1+
#     )
#     "" ;
#     drop)

# def(c99-emit-word-sig!, Name -- +IO,
#     name-is-word? if(
#         " void mw" . .name " (void);" ;,
#         drop
#     ))

# def(c99-emit-word-defs!, +IO,
#     0
#     while(dup num-names@ <,
#         dup Int->Name c99-emit-word-def!
#         1+)
#     drop)

# def(c99-emit-word-def!, Name -- +IO,
#     name-is-word? if(
#         dup typecheck-name!
#         dup .w "{" ;
#         name-word@ word-body@ c99-emit-run!
#         "}" ;;,
#         drop
#     ))

# def(c99-emit-run!, Token -- +IO,
#     c99-depth++
#     while(token-run-end? not,
#         dup c99-emit-token!
#         token-next
#     ) drop
#     c99-depth--)

# def(c99-emit-token!, Token -- +IO,
#     dup typecheck-token!

#     token-type? TOKEN_INT = if(
#         "    push(" . token-int@ .n ");" ;,

#     token-type? TOKEN_STR = if(
#         "    push((i64)(strings + " . token-value@ TokenValue->Int .n "));" ;, # FIXME: just push a string literal.

#     token-type? TOKEN_NAME = if(
#         c99-emit-word!,

#         drop
#     ))))

# def(c99-emit-word!, Token -- +IO,
#     token-name? PRIM_DIP Prim->Name = if(
#         token-args-1
#         "    { i64 d" . .d " = pop();" ;
#         c99-emit-run!
#         "      push(d" . .d "); }" ;,

#     token-name? PRIM_IF Prim->Name = if(
#         token-args-2
#         "    if (pop()) {" ;
#         dip(c99-emit-run!)
#         "    } else {" ;
#         c99-emit-run!
#         "    }" ;,

#     token-name? PRIM_WHILE Prim->Name = if(
#         token-args-2
#         "    while(1) {" ;
#         dip(c99-emit-run!)
#         "    if (!pop()) break;" ;
#         c99-emit-run!
#         "    }" ;,

#         token-name@
#         "    mw" . .name "();" ;
#     ))))

MAX_BUFFERS def-static-buffer(C99_BUFFER_DEFINED)
def(c99-buffer-defined?, Buffer -- Buffer Bool +C99,
    dup Buffer->Int C99_BUFFER_DEFINED ptr+ u8@ U8->Int)
def(c99-buffer-defined!, Buffer -- Buffer +C99,
    1 Int->U8 over Buffer->Int C99_BUFFER_DEFINED ptr+ u8!)

def(c99-emit-buffer-def!, Buffer -- +C99,
    c99-buffer-defined? if(
        drop,
        c99-buffer-defined!
        "volatile u8 b" . dup Buffer->Int .n
        " [" . buffer-size@ .n " ];" ; # TODO use buffer name
    ))

def(c99-emit-external-def!, External -- +C99, "c99-emit-external-def! not yet implemented!" panic!)

MAX_TENSOR_TYPES def-static-buffer(C99_TENSOR_TYPE_DEFINED)
def(c99-tensor-type-defined?, TensorType -- TensorType Bool +C99,
    dup TensorType->Int C99_TENSOR_TYPE_DEFINED ptr+ u8@ U8->Int)
def(c99-tensor-type-defined!, TensorType -- TensorType +C99,
    1 Int->U8 over TensorType->Int C99_TENSOR_TYPE_DEFINED ptr+ u8!)

def(c99-emit-type-def!, Type -- +C99,
    type-expand
    type-is-nominal? if(
        type-get-nominal nominal-type@ c99-emit-type-def!
    type-is-tensor? if(
        type-get-tensor
        c99-tensor-type-defined? if(
            drop,
            c99-tensor-type-defined!
            tensor-type-fst? type-is-tensor? if(
                c99-emit-type-def!
                c99-,
                ,

            )

            c99-tensor-type-defined!
            dup tensor-type-unpack
            dip(c99-emit-type-def!)
            c99-emit-type-def!

        ),
    type-is-morphism? if(
        type-get-morphism
        morphism-type-unpack
        dip(c99-emit-type-def!)
        c99-emit-type-def!,
        drop
    )))

def(c99-emit-type-sig!, Name Type -- +C99, drop2) # TODO


MAX_WORDS def-static-buffer(C99_WORD_DEFINED)
def(c99-word-defined?, Word -- Word Bool +C99,
    dup Word->Int C99_WORD_DEFINED ptr+ u8@ U8->Int)
def(c99-word-defined!, Word -- Word +C99,
    1 Int->U8 over Word->Int C99_WORD_DEFINED ptr+ u8!)

def(c99-emit-word-def!, Word -- +C99,
    c99-word-defined? if(
        drop,

        c99-word-defined!
        dup
        c99-emit-word-sig!
        c99-emit-word-body!
    ))

def(c99-emit-word-sig!, Word -- +C99,
    dup elab-word-sig!
    dup c99-emit-type-def!
    dip(word-name@) c99-emit-type-sig!)

def(c99-emit-word-body!, Word -- +C99,
    drop) # TODO

def(c99-emit-arrow-reqs!, Arrow -- +C99,
    while(dup Arrow->Int,

        arrow-op? OP_NONE = if(
            id,

        arrow-op? OP_INT = if(
            id,

        arrow-op? OP_STR = if(
            id,

        arrow-op? OP_BUFFER = if(
            arrow-op-buffer? c99-emit-buffer-def!,

        arrow-op? OP_EXTERNAL = if(
            arrow-op-external? c99-emit-external-def!,

        arrow-op? OP_WORD = if(
            arrow-op-word? c99-emit-word-def!,

        arrow-op? OP_PRIM = if(
            id,

            arrow-token@ "compiler error: Unknown op in c99-emit-arrow-reqs!" emit-fatal-error!
        )))))))

        arrow-next@
    )
    drop)

def(c99-emit-arrow-body!, Arrow -- +C99, drop)

def(c99-emit-main!, Token -- +C99,
    elab-arrow! dup
    c99-emit-arrow-reqs!

    "int main (int argc, char** argv) {" ;
    c99-emit-arrow-body!
    "    return 0;" ;
    "}" ;
    )
